name: Build and Release Executables

# Dieser Workflow wird bei jedem neuen Release gestartet
on:
  release:
    types: [ created ]

jobs:
  build:
    # Definiere eine Build-Matrix f√ºr alle jpackage Kombinationen
    strategy:
      matrix:
        include:
          # Windows builds - nur x64 (GitHub Actions hat keine ARM64 Windows Runner)
          - os: windows-latest
            arch: x64
            gradle-tasks: createWindowsExecutableX64
            artifact-pattern: "FreeXmlToolkit-x64-*.exe"
          - os: windows-latest
            arch: x64
            gradle-tasks: createWindowsMsiX64
            artifact-pattern: "FreeXmlToolkit-x64-*.msi"
          - os: windows-latest
            arch: x64
            gradle-tasks: createWindowsAppImageX64Zip
            artifact-pattern: "FreeXmlToolkit-windows-x64-app-image-*.zip"
          
          # macOS builds - native builds only (jpackage cannot cross-compile with runtime)
          - os: macos-latest  # ARM runner for native ARM builds (macOS 15 ARM64)
            arch: arm64
            gradle-tasks: createMacOSExecutableArm64
            artifact-pattern: "FreeXmlToolkit-arm64-*.dmg"
          - os: macos-latest  # ARM runner for native ARM builds (macOS 15 ARM64)
            arch: arm64
            gradle-tasks: createMacOSPkgArm64
            artifact-pattern: "FreeXmlToolkit-arm64-*.pkg"
          - os: macos-latest  # ARM runner for native ARM builds (macOS 15 ARM64)
            arch: arm64
            gradle-tasks: createMacOSAppImageArm64Zip
            artifact-pattern: "FreeXmlToolkit-macos-arm64-app-image-*.zip"
          - os: macos-15-intel  # Intel runner for native x64 builds (macOS 15 Intel)
            arch: x64
            gradle-tasks: createMacOSExecutableX64
            artifact-pattern: "FreeXmlToolkit-x64-*.dmg"
          - os: macos-15-intel  # Intel runner for native x64 builds (macOS 15 Intel)
            arch: x64
            gradle-tasks: createMacOSPkgX64
            artifact-pattern: "FreeXmlToolkit-x64-*.pkg"
          - os: macos-15-intel  # Intel runner for native x64 builds (macOS 15 Intel)
            arch: x64
            gradle-tasks: createMacOSAppImageX64Zip
            artifact-pattern: "FreeXmlToolkit-macos-x64-app-image-*.zip"
          
          # Linux builds - nur x64 (GitHub Actions hat keine ARM64 Linux Runner)
          - os: ubuntu-latest
            arch: x64
            gradle-tasks: createLinuxDebX64
            artifact-pattern: "freexmltoolkit-x64_*_amd64.deb"
          - os: ubuntu-latest
            arch: x64
            gradle-tasks: createLinuxRpmX64
            artifact-pattern: "freexmltoolkit-x64-*-1.x86_64.rpm"
          - os: ubuntu-latest
            arch: x64
            gradle-tasks: createLinuxAppImageX64Zip
            artifact-pattern: "FreeXmlToolkit-linux-x64-app-image-*.zip"

    # Der Job wird auf dem in der Matrix definierten Betriebssystem ausgef√ºhrt
    runs-on: ${{ matrix.os }}

    steps:
      # Schritt 1: Code auschecken
      - name: Checkout repository
        uses: actions/checkout@v5

      # Schritt 1.5: Datei-Zeitstempel auf aktuelle Build-Zeit setzen
      # GitHub Actions checkout setzt alle Zeitstempel auf 1980-01-01 (DOS-Epoch)
      - name: Set file timestamps to build time
        shell: bash
        run: |
          echo "Setting all file timestamps to current build time..."
          find . -type f -not -path "./.git/*" -exec touch {} \;
          echo "Timestamps updated to: $(date)"

      # Schritt 2: Java Development Kit (JDK) einrichten
      # Stelle sicher, dass du eine JDK-Version w√§hlst, die jpackage enth√§lt (JDK 14+)
      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          java-package: 'jdk+fx'
          java-version: '25'
          distribution: 'liberica'

      # Schritt 3: Gradle Wrapper ausf√ºhrbar machen (wichtig f√ºr Linux/macOS)
      - name: Make Gradle wrapper executable
        if: runner.os != 'Windows'
        run: chmod +x ./gradlew

      # Schritt 4: F√ºhre die architektur-spezifischen Gradle-Tasks aus
      - name: Build with Gradle (${{ matrix.arch }})
        run: ./gradlew ${{ matrix.gradle-tasks }}

      # Schritt 5: Lade alle erstellten Artefakte mit dem GitHub CLI hoch
      - name: Upload Release Assets (${{ matrix.arch }})
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          echo "üìÅ Contents of build/dist/ before upload:"
          ls -la build/dist/ || echo "build/dist/ directory not found"
          echo ""
          
          echo "üîç Searching for package files in subdirectories:"
          find build/dist/ -name "*.exe" -o -name "*.msi" -o -name "*.zip" -o -name "*.dmg" -o -name "*.pkg" -o -name "*.deb" -o -name "*.rpm" 2>/dev/null || echo "No package files found with find"
          echo ""
          
          # Find and upload all created files (more robust approach)
          found_files=0
          
          # Upload files matching the expected pattern
          for file in build/dist/${{ matrix.artifact-pattern }}; do
            if [ -f "$file" ]; then
              echo "üì¶ Uploading: $file ($(stat --format='%s' "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "unknown size") bytes)"
              if gh release upload ${{ github.event.release.tag_name }} "$file"; then
                echo "‚úÖ Successfully uploaded: $file"
                found_files=$((found_files + 1))
              else
                echo "‚ùå Failed to upload: $file"
              fi
            fi
          done
          
          # Also try to upload any other files in build/dist/ and subdirectories that look like packages
          shopt -s nullglob
          for extension in exe msi zip dmg pkg deb rpm; do
            # Search in build/dist/ directly
            for file in build/dist/*.$extension; do
              if [ -f "$file" ]; then
                filename=$(basename "$file")
                if ! gh release view ${{ github.event.release.tag_name }} | grep -q "$filename"; then
                  echo "üì¶ Uploading file: $file ($(stat --format='%s' "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "unknown size") bytes)"
                  if gh release upload ${{ github.event.release.tag_name }} "$file"; then
                    echo "‚úÖ Successfully uploaded: $file"
                    found_files=$((found_files + 1))
                  else
                    echo "‚ùå Failed to upload: $file"
                  fi
                fi
              fi
            done
            
            # Search in build/dist/*/ subdirectories
            for file in build/dist/*/*.$extension; do
              if [ -f "$file" ]; then
                filename=$(basename "$file")
                if ! gh release view ${{ github.event.release.tag_name }} | grep -q "$filename"; then
                  echo "üì¶ Uploading from subdirectory: $file ($(stat --format='%s' "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo "unknown size") bytes)"
                  if gh release upload ${{ github.event.release.tag_name }} "$file"; then
                    echo "‚úÖ Successfully uploaded: $file"
                    found_files=$((found_files + 1))
                  else
                    echo "‚ùå Failed to upload: $file"
                  fi
                fi
              fi
            done
          done
          
          if [ $found_files -eq 0 ]; then
            echo "‚ö†Ô∏è  No files were uploaded!"
            echo "Expected pattern: ${{ matrix.artifact-pattern }}"
            exit 1
          else
            echo "üéâ Successfully uploaded $found_files file(s)"
          fi
