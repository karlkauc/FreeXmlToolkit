/*
 * FreeXMLToolkit - Universal Toolkit for XML
 * Copyright (c) Karl Kauc 2024.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 */

package org.fxt.freexmltoolkit.service;

import org.apache.fop.apps.FOUserAgent;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.poi.ooxml.POIXMLProperties;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.fxt.freexmltoolkit.di.ServiceRegistry;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Date;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Central service class for export metadata.
 * Provides application and user data for all export formats.
 * <p>
 * Supports:
 * - XML/XSD/XSLT/Schematron: XML comments with duplicate prevention
 * - HTML: meta tags
 * - Excel: POI document properties
 * - PDF: FOP user agent metadata
 * - JSON: _metadata object
 * - SVG: Dublin Core metadata
 */
public class ExportMetadataService {

    private static final Logger logger = LogManager.getLogger(ExportMetadataService.class);

    private static final String APP_NAME = "FreeXmlToolkit";
    private static final String FALLBACK_VERSION = "1.0.0";

    /**
     * Regex pattern to detect existing FreeXmlToolkit metadata comments.
     * Matches comments like:
     * <!--
     *   Generated by FreeXmlToolkit v1.0.0
     *   Author: ...
     *   Company: ...
     *   Date: ...
     * -->
     */
    private static final Pattern METADATA_COMMENT_PATTERN = Pattern.compile(
            "\\n?<!--[\\s\\S]*?Generated by FreeXmlToolkit[\\s\\S]*?-->\\s*\\n?",
            Pattern.DOTALL
    );

    /**
     * Pattern to find XML declaration.
     */
    private static final Pattern XML_DECLARATION_PATTERN = Pattern.compile("(<\\?xml[^?]*\\?>)");

    private final PropertiesService propertiesService;

    public ExportMetadataService() {
        this.propertiesService = ServiceRegistry.get(PropertiesService.class);
    }

    /**
     * Constructor for testing with injected PropertiesService.
     */
    public ExportMetadataService(PropertiesService propertiesService) {
        this.propertiesService = propertiesService;
    }

    // === Getter for metadata ===

    /**
     * Gets the application name.
     *
     * @return "FreeXmlToolkit"
     */
    public String getAppName() {
        return APP_NAME;
    }

    /**
     * Gets the application version from the JAR manifest or fallback.
     *
     * @return Version string like "1.0.0"
     */
    public String getAppVersion() {
        String version = getClass().getPackage().getImplementationVersion();
        return (version != null && !version.isEmpty()) ? version : FALLBACK_VERSION;
    }

    /**
     * Gets the application name with version.
     *
     * @return "FreeXmlToolkit v1.0.0"
     */
    public String getAppNameWithVersion() {
        return APP_NAME + " v" + getAppVersion();
    }

    /**
     * Gets the user name from settings.
     *
     * @return User name or null if not set
     */
    public String getUserName() {
        if (propertiesService == null) {
            return null;
        }
        String userName = propertiesService.get("user.name");
        return (userName != null && !userName.isBlank()) ? userName.trim() : null;
    }

    /**
     * Gets the user's company from settings.
     *
     * @return Company name or null if not set
     */
    public String getUserCompany() {
        if (propertiesService == null) {
            return null;
        }
        String company = propertiesService.get("user.company");
        return (company != null && !company.isBlank()) ? company.trim() : null;
    }

    /**
     * Gets the current timestamp in ISO-8601 format.
     *
     * @return Timestamp like "2025-12-10T14:30:00"
     */
    public String getTimestamp() {
        return LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
    }

    // === Format-specific helper methods ===

    /**
     * Generates XML comment for metadata.
     * Empty fields (Author, Company) are omitted.
     *
     * @return XML comment string
     */
    public String generateXmlComment() {
        StringBuilder sb = new StringBuilder();
        sb.append("\n<!--\n");
        sb.append("  Generated by ").append(getAppNameWithVersion()).append("\n");

        String userName = getUserName();
        if (userName != null) {
            sb.append("  Author: ").append(userName).append("\n");
        }

        String company = getUserCompany();
        if (company != null) {
            sb.append("  Company: ").append(company).append("\n");
        }

        sb.append("  Date: ").append(getTimestamp()).append("\n");
        sb.append("-->\n");
        return sb.toString();
    }

    /**
     * Generates HTML meta tags for metadata.
     * Empty fields are omitted.
     *
     * @return HTML meta tags string
     */
    public String generateHtmlMetaTags() {
        StringBuilder sb = new StringBuilder();
        sb.append("  <meta name=\"generator\" content=\"").append(getAppNameWithVersion()).append("\">\n");

        String userName = getUserName();
        if (userName != null) {
            sb.append("  <meta name=\"author\" content=\"").append(escapeHtml(userName)).append("\">\n");
        }

        String company = getUserCompany();
        if (company != null) {
            sb.append("  <meta name=\"company\" content=\"").append(escapeHtml(company)).append("\">\n");
        }

        sb.append("  <meta name=\"date\" content=\"").append(getTimestamp()).append("\">\n");
        return sb.toString();
    }

    /**
     * Sets Excel document properties.
     *
     * @param workbook The XSSFWorkbook to set properties on
     * @param title    The document title
     */
    public void setExcelMetadata(XSSFWorkbook workbook, String title) {
        if (workbook == null) {
            logger.warn("Cannot set Excel metadata: workbook is null");
            return;
        }

        try {
            POIXMLProperties props = workbook.getProperties();

            // Core Properties
            POIXMLProperties.CoreProperties core = props.getCoreProperties();
            String userName = getUserName();
            if (userName != null) {
                core.setCreator(userName);
            }
            if (title != null && !title.isBlank()) {
                core.setTitle(title);
            }
            core.setDescription("Generated by " + getAppNameWithVersion());
            core.setCreated(Optional.of(new Date()));

            // Extended Properties
            POIXMLProperties.ExtendedProperties ext = props.getExtendedProperties();
            ext.setApplication(getAppNameWithVersion());
            String company = getUserCompany();
            if (company != null) {
                ext.setCompany(company);
            }

            logger.debug("Excel metadata set successfully for: {}", title);
        } catch (Exception e) {
            logger.error("Failed to set Excel metadata", e);
        }
    }

    /**
     * Generates JSON _metadata object.
     * Empty fields are omitted.
     *
     * @return JSON metadata object string (without surrounding braces of root object)
     */
    public String generateJsonMetadata() {
        StringBuilder sb = new StringBuilder();
        sb.append("\"_metadata\": {\n");
        sb.append("    \"generator\": \"").append(getAppName()).append("\",\n");
        sb.append("    \"version\": \"").append(getAppVersion()).append("\",\n");

        String userName = getUserName();
        if (userName != null) {
            sb.append("    \"author\": \"").append(escapeJson(userName)).append("\",\n");
        }

        String company = getUserCompany();
        if (company != null) {
            sb.append("    \"company\": \"").append(escapeJson(company)).append("\",\n");
        }

        sb.append("    \"generatedAt\": \"").append(getTimestamp()).append("Z\"\n");
        sb.append("  }");
        return sb.toString();
    }

    /**
     * Sets PDF metadata via FOUserAgent.
     *
     * @param foUserAgent The FOP user agent
     * @param title       The document title
     */
    public void setPdfMetadata(FOUserAgent foUserAgent, String title) {
        if (foUserAgent == null) {
            logger.warn("Cannot set PDF metadata: foUserAgent is null");
            return;
        }

        foUserAgent.setProducer(getAppNameWithVersion());
        foUserAgent.setCreator(getAppName());

        if (title != null && !title.isBlank()) {
            foUserAgent.setTitle(title);
        }

        String userName = getUserName();
        if (userName != null) {
            foUserAgent.setAuthor(userName);
        }

        logger.debug("PDF metadata set successfully for: {}", title);
    }

    /**
     * Generates SVG metadata element with Dublin Core.
     *
     * @return SVG metadata element string
     */
    public String generateSvgMetadata() {
        StringBuilder sb = new StringBuilder();
        sb.append("  <metadata>\n");
        sb.append("    <rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n");
        sb.append("             xmlns:dc=\"http://purl.org/dc/elements/1.1/\">\n");
        sb.append("      <rdf:Description>\n");
        sb.append("        <dc:source>").append(getAppNameWithVersion()).append("</dc:source>\n");

        String userName = getUserName();
        if (userName != null) {
            sb.append("        <dc:creator>").append(escapeXml(userName)).append("</dc:creator>\n");
        }

        String company = getUserCompany();
        if (company != null) {
            sb.append("        <dc:publisher>").append(escapeXml(company)).append("</dc:publisher>\n");
        }

        sb.append("        <dc:date>").append(getTimestamp()).append("</dc:date>\n");
        sb.append("      </rdf:Description>\n");
        sb.append("    </rdf:RDF>\n");
        sb.append("  </metadata>\n");
        return sb.toString();
    }

    // === Duplicate prevention for XML-based formats ===

    /**
     * Checks if the XML content already contains FreeXmlToolkit metadata.
     *
     * @param xmlContent The XML string
     * @return true if metadata already exists
     */
    public boolean hasExistingMetadata(String xmlContent) {
        if (xmlContent == null || xmlContent.isEmpty()) {
            return false;
        }
        return METADATA_COMMENT_PATTERN.matcher(xmlContent).find();
    }

    /**
     * Removes existing FreeXmlToolkit metadata comments from the XML content.
     *
     * @param xmlContent The XML string with possibly existing metadata
     * @return The XML string without existing metadata comments
     */
    public String removeExistingMetadata(String xmlContent) {
        if (xmlContent == null || xmlContent.isEmpty()) {
            return xmlContent;
        }
        return METADATA_COMMENT_PATTERN.matcher(xmlContent).replaceAll("");
    }

    /**
     * Adds metadata to XML content or updates existing metadata.
     * Prevents duplicates: If a FreeXmlToolkit comment already exists,
     * it is replaced instead of adding a new one.
     *
     * @param xmlContent The original XML string
     * @return The XML string with updated metadata
     */
    public String addOrUpdateXmlMetadata(String xmlContent) {
        if (xmlContent == null || xmlContent.isEmpty()) {
            return xmlContent;
        }

        // First remove existing metadata (if present)
        boolean hadExisting = hasExistingMetadata(xmlContent);
        String cleanContent = removeExistingMetadata(xmlContent);

        if (hadExisting) {
            logger.debug("Updating existing FreeXmlToolkit metadata comment");
        } else {
            logger.debug("Adding new FreeXmlToolkit metadata comment");
        }

        // Generate new metadata
        String metadataComment = generateXmlComment();

        // Find position for metadata: after XML declaration, before root element
        Matcher xmlDeclMatcher = XML_DECLARATION_PATTERN.matcher(cleanContent);

        if (xmlDeclMatcher.find()) {
            // Insert after XML declaration
            int insertPos = xmlDeclMatcher.end();
            return cleanContent.substring(0, insertPos) + metadataComment + cleanContent.substring(insertPos);
        } else {
            // No XML declaration present - insert at beginning
            return metadataComment + cleanContent;
        }
    }

    // === Utility methods ===

    private String escapeHtml(String text) {
        if (text == null) return "";
        return text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;");
    }

    private String escapeXml(String text) {
        if (text == null) return "";
        return text.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
                .replace("\"", "&quot;")
                .replace("'", "&apos;");
    }

    private String escapeJson(String text) {
        if (text == null) return "";
        return text.replace("\\", "\\\\")
                .replace("\"", "\\\"")
                .replace("\n", "\\n")
                .replace("\r", "\\r")
                .replace("\t", "\\t");
    }
}
